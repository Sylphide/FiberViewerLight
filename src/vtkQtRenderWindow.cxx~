/*=========================================================================

  Program:   FiberViewer
  Module:    $RCSfile: vtkQtRenderWindow.cxx,v $
  Language:  C++
  Date:      $Date: 2007/08/14 19:55:44 $
  Version:   $Revision: 1.1 $
  Author:    Matthieu Jomier

  Copyright (c) 2004 NeuroImaging Lab @ UNC. All rights reserved.
  See NeuroLibCopyright.txt for details.

     This software is distributed WITHOUT ANY WARRANTY; without even 
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR 
     PURPOSE.  See the above copyright notices for more information.

=========================================================================*/
#include "vtkRenderWindowInteractor.h"  
#include "vtkQtRenderWindow.h"  
#include "vtkOpenGLRenderer.h"  
#include "vtkOpenGLProperty.h"  
#include "vtkOpenGLTexture.h"  
#include "vtkOpenGLCamera.h"  
#include "vtkOpenGLLight.h"  
#include "vtkOpenGLActor.h"  
#include "vtkCommand.h"  
#include "vtkOpenGLPolyDataMapper.h"  
//#include "vtkQGLWindowQT.h"  
//#include "vtkQtObjectFactory.h"  
#include "vtkIdList.h"  
#include "vtkRendererCollection.h"
#include <QGLWidget>
#include <QGLFormat>
  
vtkQtRenderWindow::vtkQtRenderWindow(QWidget *parent, const char* name, const QGLWidget *shareWidget, WFlags f):  
      QGLWidget (parent, shareWidget, f)   
{  
  this->TextureResourceIds = vtkIdList::New();  
  this->Size[0] = -1;  
  this->Size[1] = -1;  
    qtRenWinInt = NULL;  
    
#if defined(WIN32)  
  this->hLastWinId = NULL;  
  this->hLastDC = NULL;  
#endif  
    setFocusPolicy(Qt::WheelFocus);  
}  
  
vtkQtRenderWindow::vtkQtRenderWindow(const QGLFormat & format, QWidget *parent, const char *name, const QGLWidget *shared):  
		QGLWidget(format, parent, shared)  
{  
    this->TextureResourceIds = vtkIdList::New();  
  this->Size[0] = -1;  
  this->Size[1] = -1;  
    
#if defined(WIN32)  
  this->hLastWinId = NULL;  
  this->hLastDC = NULL;  
#endif  
      
 };  
  
  
#define VTK_MAX_LIGHTS 8  
  
  
vtkQtRenderWindow::~vtkQtRenderWindow()  
{  
#if defined(WIN32)  
  if (this->hLastDC != NULL)  
  {  
    ::ReleaseDC(this->hLastWinId, this->hLastDC);  
  }  
#endif  
    
    // tell each of the renderers that this render window/graphics context  
    // is being removed (the RendererCollection is removed by vtkRenderWindow's  
    // destructor)  
  vtkRenderer *ren;  
    this->Renderers->InitTraversal();  
    for ( ren = (vtkRenderer*)this->Renderers->GetNextItemAsObject(); ren != NULL; ren = (vtkRenderer*)this->Renderers->GetNextItemAsObject() )  
    {  
    ren->SetRenderWindow(NULL);  
    }  
    
//  if (this->mMyQTWidget)  
  {  
    GLuint id;  
      
    this->MakeCurrent();  
      
    short cur_light;  
      
    /* first delete all the old lights */  
    for (cur_light = GL_LIGHT0; cur_light < GL_LIGHT0+VTK_MAX_LIGHTS; cur_light++)  
    {  
      glDisable((GLenum)cur_light);  
    }  
      
    /* now delete all textures */  
    glDisable(GL_TEXTURE_2D);  
    for (int i = 1; i < this->TextureResourceIds->GetNumberOfIds(); i++)  
    {  
      id = (GLuint) this->TextureResourceIds->GetId(i);  
#ifdef GL_VERSION_1_1  
      if (glIsTexture(id))  
      {  
        glDeleteTextures(1, &id);  
      }  
#else  
      if (glIsList(id))  
      {  
        glDeleteLists(id,1);  
      }  
#endif  
    }  
      
    glFinish();  
      
      
//    delete this->mMyQTWidget;  
  }  
    
  this->TextureResourceIds->Delete();  
}  
  
  
void vtkQtRenderWindow::PrintSelf(ostream& os, vtkIndent indent)  
{  
  this->vtkRenderWindow::PrintSelf(os, indent);  
    
  QGLFormat myFormat = format() ;  
  //  os << indent << "qGLVersion: " << qGLVersion() << endl ;  
  os << indent << "doubleBuffer: " << myFormat.doubleBuffer() << endl ;  
  os << indent << "depth: " << myFormat.depth() << endl ;  
  os << indent << "rgba: " << myFormat.rgba() << endl ;  
  os << indent << "alpha: " << myFormat.alpha() << endl ;  
  os << indent << "accum: " << myFormat.accum() << endl ;  
  os << indent << "stencil: " << myFormat.stencil() << endl ;  
  os << indent << "stereo: " << myFormat.stereo() << endl ;  
  os << indent << "directRendering: " << myFormat.directRendering() << endl ;  
}  
  
  
void vtkQtRenderWindow::Start(void)  
{  
  //  
  // Initialize the QGLWidget part of the widget if it has not  
  // been initialized so far.  
  //  
//  if (! this->mMyQTWidget)  
  {  
    QGLFormat format;  
	 format.setDoubleBuffer(((QGLWidget*)this)->doubleBuffer()!=0);  
    format.setStereo(this->StereoCapableWindow!=0);  
    format.setRgba(true) ;  
    format.setDepth(true) ;  
    format.setDirectRendering(true) ;  
      
//    QWidget *widgetParent;  
//    QGLWidget *widgetShared;  
//    char* widgetName;  
  //  vtkQtObjectFactory::GetQtBase(widgetParent, widgetName, widgetShared);  
    //this->mMyQTWidget = new vtkQtRenderWindowQT(format, widgetParent, widgetName, widgetShared);  
      
    //this->mMyQTWidget->SetVTKPtr(this);  
  //  this->SetQTPtr(this->mMyQTWidget);  
      
    this->WindowInitialize();  
  }  
  this->MakeCurrent() ;  
}  
  
  
// End the rendering process and display the image.  
void vtkQtRenderWindow::Frame(void)  
{  
/*  this->MakeCurrent();  
  glFlush() ;  
  if ((!this->AbortRender) && // the render is not being aborted  
    ((QGLWidget*)this)->DoubleBuffer &&    // double buffering is enabled on VTK side  
    this->SwapBuffers )  
  {  
    // VTK wants us to swap buffers  
    //this->mMyQTWidget->Frame() ;  
  }*/  
}  
  
  
// Initialize the window for rendering.  
void vtkQtRenderWindow::WindowInitialize(void)  
{  
  if (this->Mapped)  
  {  
    return;  
  }  
/*  if (! this->mMyQTWidget)  
  {  
    vtkErrorMacro("vtkQtRenderWindow::WindowInitialize() was called before void vtkQtRenderWindow::Start()");  
  }*/  
    
    
    int width, height;  
    
  QSize size = sizeHint();  
  width = ((this->Size[0] > 0) ? this->Size[0] : size.width());  
  height = ((this->Size[1] > 0) ? this->Size[1] : size.height());  
    
    this->MakeCurrent();  
    
  glClearColor(0.0, 0.0, 0.0, 0.0) ;  
    
  this->OpenGLInit();  
    
    glAlphaFunc(GL_GREATER,0);  
    
    this->Mapped = 1;  
    
  // I do not know why the default size is not just set to 300 in the constructor.  
  // But it needs to be set for the first render.  
  this->Size[0] = width;  
  this->Size[1] = height;  
}  
  
  
void vtkQtRenderWindow::SetFullScreen(int arg) {  
  //  
  // We do not need to do anything if the FullScreen mode  
  // is already set to the specified value.  
  //  
  if( this->FullScreen == arg ) return ;  
    
  //  
  // :TODO: Fri Apr 21 16:41:06 2000 Pagey  
  // This is not implemented in QGLWidget yet. Hence, we  
  // will ignore it.  
  //  
  vtkDebugMacro(<< " QGLWidget::SetFullScreen() not supported by QGLWidget yet.\n") ;  
}  
  
  
void vtkQtRenderWindow::WindowRemap(void) {  
  //  
  // :TODO: Fri Apr 21 16:44:35 2000 Pagey  
  // I am not sure why we would ever need to do this under Qt.  
  // Hence, I have not done anything here yet.  
  //  
  vtkDebugMacro(<< " QGLWidget::WindowRemap() not supported by QGLWidget yet.\n") ;  
    
  short cur_light;  
    
  /* first delete all the old lights */  
  for (cur_light = GL_LIGHT0; cur_light < GL_LIGHT0+VTK_MAX_LIGHTS; cur_light++)  
    {  
    glDisable(cur_light);  
    }  
    
  //  this->WindowInitialize();  
    this->Modified();  
    
}  
  
  
void vtkQtRenderWindow::PrefFullScreen(void) {  
  //  
  // :TODO: Fri Apr 21 16:46:30 2000 Pagey  
  // Since, SetFullScreen() is not supported yet, this is useless.  
  //  
  vtkDebugMacro(<< " QGLWidget::PrefFullScreen() not supported by QGLWidget yet.\n") ;  
}  
  
  
  
  
void vtkQtRenderWindow::SetSizeSuper(int w,int h)  
{  
  if( this->Interactor )   
  {  
    this->Interactor->UpdateSize(w, h) ;  
  }  
  vtkOpenGLRenderWindow::SetSize(w, h);  
};  
  
  
void vtkQtRenderWindow::SetSize(int w, int h)  
{  
//  if (this->mMyQTWidget)  
  /*{  
    SetSize(w, h);  
  }*/  
/*  else  
  {  
    vtkErrorMacro("vtkQtRenderWindow::SetSize() was called before void vtkQtRenderWindow::Start()");  
  }*/  
    
  if( this->Interactor )  
  {  
    this->Interactor->UpdateSize(w, h) ;  
  }  
}  
  
void vtkQtRenderWindow::MakeCurrent()  
{  
  makeCurrent();  
//  if (this->mMyQTWidget)  
/*  {  
    if (vtkQGLWindowQT::mCurrentWidget != this->mMyQTWidget)  
    {  
      vtkQGLWindowQT::mCurrentWidget = this->mMyQTWidget;  
      this->mMyQTWidget->makeCurrent();  
    }  
  }*/  
}  
  
void vtkQtRenderWindow::Render(void)  
{  
  {  
    {  
      GLenum error = glGetError();  
      if (error!=GL_NO_ERROR)  
      {  
#ifdef _WIN32  
        vtkErrorMacro(<<"OpenGL error before vtkQtRenderWindow::Render(): "<<gluErrorString(error)<<" ("<<error<<")");  
#else  
        vtkErrorMacro(<<"OpenGL error before vtkQtRenderWindow::Render(): ("<<error<<")");  
#endif  
      }  
    }  
    MakeCurrent();  
    updateGL();  
    {  
      GLenum error = glGetError();  
      if (error!=GL_NO_ERROR)  
      {  
#ifdef _WIN32  
        vtkErrorMacro(<<"OpenGL error before vtkQtRenderWindow::Render(): "<<gluErrorString(error)<<" ("<<error<<")");  
#else  
        vtkErrorMacro(<<"OpenGL error before vtkQtRenderWindow::Render(): ("<<error<<")");  
#endif  
      }  
    }  
  }  
/*  else  
  {  
    vtkErrorMacro("vtkQtRenderWindow::Render() was called before void vtkQtRenderWindow::Start()");  
  }*/  
}  
  
  
  
// Return NULL if Start wasn't called!!! Display errormessage  
QWidget* vtkQtRenderWindow::GetQTPtr()  
{  
/*  QWidget* widget = vtkQGLPtrToQT::GetQTPtr();  
  if (widget == NULL)  
  {  
    vtkErrorMacro("No QT Widget was created before void vtkQtRenderWindow::Start()");  
  }*/  
  return 0; //widget;  
}  
  
  
  
  
  
  
  
void *vtkQtRenderWindow::GetGenericDisplayId()  
{  
  //  (!this->mMyQTWidget)  
  {  
    vtkErrorMacro("vtkQtRenderWindow::GetGenericDisplayId() returns NULL");  
    return NULL;  
  }  
};  
  
  
  
void *vtkQtRenderWindow::GetGenericDrawable()  
{  
  //  (!this->mMyQTWidget)  
  {  
    vtkErrorMacro("vtkQtRenderWindow::GetGenericDrawable() returns NULL");  
    return NULL;  
  }  
};  
  
  
  
void *vtkQtRenderWindow::GetGenericContext()  
{  
/*  if (!this->mMyQTWidget)  
  {  
    vtkErrorMacro("vtkQtRenderWindow::GetGenericContext() returns NULL");  
    return NULL;  
  }*/  
    
#if defined(WIN32)  
  if (this->hLastDC != NULL)  
  {  
    if (this->hLastWinId != winId())  
    {  
      ::ReleaseDC(this->hLastWinId, this->hLastDC);  
      this->hLastDC = NULL;  
    }  
  }  
  if (this->hLastDC == NULL)  
  {  
    this->hLastWinId = winId();  
    this->hLastDC = ::GetDC(this->hLastWinId);  
  }  
  return this->hLastDC;  
#else  
  return (void *)(handle());  
#endif  
};  
  
  
  
void *vtkQtRenderWindow::GetGenericWindowId()  
{  
/*  if (!this->mMyQTWidget)  
  {  
    vtkErrorMacro("vtkQtRenderWindow::GetGenericWindowId() returns NULL");  
    return NULL;  
  }*/  
    
  return (void *)(winId());  
};  
  
  
  
void *vtkQtRenderWindow::GetGenericParentId()  
{  
//  if (!this->mMyQTWidget)  
  {  
    vtkErrorMacro("vtkQtRenderWindow::GetGenericParentId() returns NULL");  
    return NULL;  
  }  
    
  if (parentWidget())  
    return (void *)(parentWidget()->winId());  
    
  return NULL;  
};  
  
  
  
  
  
int vtkQtRenderWindow::GetStereoCapableWindow()  
{  
/*  if (!this->mMyQTWidget)  
  {  
    return vtkOpenGLRenderWindow::GetStereoCapableWindow();  
  }*/  
  
  QGLFormat myFormat = format();  
  
  return myFormat.stereo();  
}  
  
  
  
void vtkQtRenderWindow::StereoMidpoint()  
{  
/*  int leftEye = 1;  
  this->InvokeEvent(vtkQtObjectFactory::StereoOneEyeEndEvent,(void*)leftEye);  */  
  vtkOpenGLRenderWindow::StereoMidpoint();  
}  
  
  
  
void vtkQtRenderWindow::StereoRenderComplete()  
{  
  /*int leftEye = 0;  
  this->InvokeEvent(vtkQtObjectFactory::StereoOneEyeEndEvent,(void*)leftEye);  */  
  vtkOpenGLRenderWindow::StereoRenderComplete();  
}  
  
  
void vtkQtRenderWindow::SetInteractor(vtkQtRenderWindowInteractor* arenwin) {  
    qtRenWinInt = arenwin;  
  vtkRenderWindow::SetInteractor(arenwin);  
}  
  
  
void vtkQtRenderWindow::mousePressEvent(QMouseEvent *me) {  
 if (qtRenWinInt)  
    qtRenWinInt->mousePressEvent(me);  
}  
  
void vtkQtRenderWindow::mouseReleaseEvent(QMouseEvent *me) {  
  if (qtRenWinInt)  
    qtRenWinInt->mouseReleaseEvent(me);  
}  
  
void vtkQtRenderWindow::mouseMoveEvent(QMouseEvent *me) {  
  if (qtRenWinInt)  
    qtRenWinInt->mouseMoveEvent(me);  
}  
  
void vtkQtRenderWindow::keyPressEvent(QKeyEvent *ke) {  
  if (qtRenWinInt)  
    qtRenWinInt->keyPressEvent(ke);  
}  
